包括的なコメント分析を含む GitHub issue を分析し修正してください: $ARGUMENTS。

以下の手順に従ってください:

1.  `$ARGUMENTS` が提供されているかを確認する。`$ARGUMENTS` が指定されていない場合は、即座にプロセスを終了する。終了時は、ユーザーに issue 番号の引数を渡すよう促す。

2.  **現在のブランチを確認**:
    - 現在のブランチが `main` や `master` ではなく、フィーチャーブランチ（例：`feature/*`）であることを確認する。
    - 現在のブランチが `main` や `master` の場合、プロセスを終了し、ユーザーに新しいフィーチャーブランチを作成して切り替えるよう促す。
    - issue 番号とタイトルに基づいてブランチ名を提案する（例：`feature/issue-$ISSUE_NUMBER-$SHORT_TITLE`）。
    - `git checkout -b <ブランチ名>` を使用してブランチを作成し切り替える手順を提供する。

3.  **包括的な issue 分析**:
    - `gh issue view` を使用して、タイトル、説明、ラベルを含む issue の詳細を取得する。
    - `gh api repos/:owner/:repo/issues/$ISSUE_NUMBER/comments` を使用して issue のすべてのコメントを取得する。
    - 会話スレッド全体を分析して以下を理解する:
      - 元の問題提起
      - コメント内の明確化や追加要求
      - 技術的な議論と提案された解決策
      - 言及されたアーキテクチャの決定や変更
      - 実装の制約や設定

4.  **理解フェーズ**:
    - 元の issue 説明とすべてのコメント議論を統合する
    - 現在の実装アプローチ vs コメントで議論された修正アプローチを特定する
    - 言及された具体的な技術要件、制約、またはアーキテクチャの決定に注目する
    - 元のスコープを変更する「決定」または「結論」コメントに特に注意を払う

5.  **実装計画**:
    - 完全な会話分析に基づいて、包括的な実装計画を作成する
    - コメントがアーキテクチャの変更を示唆している場合、元の issue 説明よりもそれらを優先する
    - 議論で言及された後方互換性の要件を考慮する
    - コメントで議論されたマイグレーション戦略を計画する

6.  完全な理解に基づいて、関連ファイルについてコードベースを検索する。

7.  **実装**:
    - issue + コメント分析からの最終合意に従って変更を実装する
    - コメントで議論された具体的な実装パターンやアプローチに従う
    - コメントで明示的に破壊的変更が許容されるとされていない限り、既存 API との互換性を確保する

8.  **テストと検証**:
    - issue + コメントからの要件に修正が一致することを検証するテストを記述し実行する
    - コメント議論で言及されたエッジケースや具体的なシナリオをテストする
    - コメントで明示的に放棄されていない限り、後方互換性を確保する

9.  プロジェクト標準に従ってコードがリントと型チェックを通ることを確保する。

10. **コミットメッセージ**:
    - issue とコメントからの主要な決定の両方を参照する説明的なコミットメッセージを作成する
    - コメント議論からの関連コンテキストを含める

**基本的な issue 修正との主な違い**:
- **完全な会話コンテキスト**: 元の issue だけでなく、すべてのコメントを読んで理解する
- **優先度処理**: コメントには元の issue を上書きする更新された要件が含まれることが多い
- **アーキテクチャ認識**: コメントには重要なアーキテクチャの決定や変更が含まれる場合がある
- **実装ガイダンス**: コメントには具体的な技術的ガイダンスや制約が含まれることが多い

**無効なブランチの場合のプロンプト例**:
「現在 main/master ブランチにいます。issue を修正する前にフィーチャーブランチを作成して切り替えてください。提案ブランチ名: `feature/issue-$ISSUE_NUMBER-$SHORT_TITLE`」

すべての GitHub 関連タスクには GitHub CLI（`gh`）を使用することを忘れずに。